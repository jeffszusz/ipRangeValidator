// Generated by CoffeeScript 1.4.0
(function() {

  describe("ipRangeValidator", function() {
    beforeEach(function() {
      return this.validator = new ipRangeValidator();
    });
    it("should be defined", function() {
      return expect(this.validator).toBeDefined();
    });
    it("should have a noCollisions method", function() {
      return expect(this.validator.noCollisions).toBeDefined();
    });
    it("should have a _noPublicIpCollisions method", function() {
      return expect(this.validator._noPublicIpCollisions).toBeDefined();
    });
    it("should have a _noRangeCollisions method", function() {
      return expect(this.validator._noRangeCollisions).toBeDefined();
    });
    it("should have a dot2num method", function() {
      return expect(this.validator.dot2num).toBeDefined();
    });
    it("should have a num2dot method", function() {
      return expect(this.validator.num2dot).toBeDefined();
    });
    describe("dot2num", function() {
      return it("should take an ip address in the form 10.0.0.1 and output a number", function() {
        return expect(this.validator.dot2num('192.168.0.1')).toBe(3232235521);
      });
    });
    describe("num2dot", function() {
      return it("should take a number and output an ip address in the form 10.0.0.1", function() {
        return expect(this.validator.num2dot(3232235521)).toBe('192.168.0.1');
      });
    });
    return describe("collision detection", function() {
      beforeEach(function() {
        return this.existingRanges = [
          {
            startIp: '10.10.1.1',
            endIp: '10.10.1.255',
            publicIp: '8.8.8.8'
          }, {
            startIp: '10.10.1.1',
            endIp: '10.10.1.255',
            publicIp: '8.8.8.4'
          }, {
            startIp: '10.11.1.1',
            endIp: '10.11.1.255',
            publicIp: '8.8.8.8'
          }
        ];
      });
      afterEach(function() {
        return this.existingRanges = [];
      });
      describe("_noPublicIpCollisions", function() {
        it("should return false if publicIp is present in existing ranges", function() {
          var newRange;
          newRange = {
            publicIp: '8.8.8.4'
          };
          return expect(this.validator._noPublicIpCollisions(newRange, this.existingRanges)).toBe(false);
        });
        return it("should return true if publicIp is absent from existing ranges", function() {
          var newRange;
          newRange = {
            publicIp: '8.8.8.5'
          };
          return expect(this.validator._noPublicIpCollisions(newRange, this.existingRanges)).toBe(true);
        });
      });
      describe("_noRangeCollisions", function() {
        it("should return false if startIp is in an existing range", function() {
          var newRange;
          newRange = {
            startIp: '10.10.1.20',
            endIp: '10.10.1.100'
          };
          return expect(this.validator._noRangeCollisions(newRange, this.existingRanges)).toBe(false);
        });
        it("should return true if startIp is not in an existing range", function() {
          var newRange;
          newRange = {
            startIp: '10.10.2.20',
            endIp: '10.10.2.100'
          };
          return expect(this.validator._noRangeCollisions(newRange, this.existingRanges)).toBe(true);
        });
        it("should return false if endIp is in an existing range", function() {
          var newRange;
          newRange = {
            startIp: '10.10.1.20',
            endIp: '10.10.1.100'
          };
          return expect(this.validator._noRangeCollisions(newRange, this.existingRanges)).toBe(false);
        });
        return it("should return true if endIp is not in an existing range", function() {
          var newRange;
          newRange = {
            startIp: '10.10.2.20',
            endIp: '10.10.2.100'
          };
          return expect(this.validator._noRangeCollisions(newRange, this.existingRanges)).toBe(true);
        });
      });
      return describe("noCollisions", function() {
        beforeEach(function() {
          return this.newRange = {
            startIp: '192.168.0.1',
            endIp: '192.168.0.255',
            publicIp: '3.4.5.200'
          };
        });
        afterEach(function() {
          return this.newRange = {};
        });
        it("should call _noPublicIpCollisions and _noRangeCollisions", function() {
          spyOn(this.validator, '_noPublicIpCollisions').andCallThrough();
          spyOn(this.validator, '_noRangeCollisions').andCallThrough();
          this.validator.noCollisions(this.newRange, this.existingRanges);
          expect(this.validator._noPublicIpCollisions).toHaveBeenCalledWith(this.newRange, this.existingRanges);
          return expect(this.validator._noRangeCollisions).toHaveBeenCalledWith(this.newRange, this.existingRanges);
        });
        it("should be true if _noPublicIpCollisions and _noRangeCollisions are", function() {
          spyOn(this.validator, '_noPublicIpCollisions').andReturn(true);
          spyOn(this.validator, '_noRangeCollisions').andReturn(true);
          return expect(this.validator.noCollisions(this.newRange, this.existingRanges)).toBe(true);
        });
        it("should be false if _noPublicIpCollisions is", function() {
          spyOn(this.validator, '_noPublicIpCollisions').andReturn(false);
          spyOn(this.validator, '_noRangeCollisions').andReturn(true);
          return expect(this.validator.noCollisions(this.newRange, this.existingRanges)).toBe(false);
        });
        return it("should be false if _noRangeCollisions is", function() {
          spyOn(this.validator, '_noPublicIpCollisions').andReturn(true);
          spyOn(this.validator, '_noRangeCollisions').andReturn(false);
          return expect(this.validator.noCollisions(this.newRange, this.existingRanges)).toBe(false);
        });
      });
    });
  });

}).call(this);
